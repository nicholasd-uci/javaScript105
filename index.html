<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>To-Do List</title>
  <style>
    .green {
      color: green
    }
  </style>
</head>
​
<body>
  <form>
    <p>
      <label for="item">item</label>
      <input type="text" name="item" id="item">
    </p>
    <p>
      <button id='addItem'>Add Item</button>
    </p>
  </form>
​
  <ul id="items"></ul>
​
​
​
  <script>
    // creates array called items. If there's something already in localStorage for it, stores each item from input onto localStorage OR when the array is empty it creates the array in localStorage then uses it to store inputs in.
    // if array is empty, it's null value. null is a bulleon value where null = false. Q is describing it like it's a kinda fake-ish false using the term "falsey".
    // so add || [] after telling it to add to the array so it will also work when there's a null array.
    let items = JSON.parse(localStorage.getItem('items')) || []

    // IF the items array is empty, it skips this loop because i will be 0, so it can't be less than an items.length of 0.//
    // so IF someone had alredy been there and there's items already in the array on localStorage, this starts loop that puts what was already in the array on the screen
    for (let i=0; i<items.length; i++) {

      // for each i, this creates a li (it creates it as an empty li, we fill the li in the next steps)
      let itemElem = document.createElement('li')
      
      // so the li we just created (itemElem), give it the custom property (aka: assigning a dataset) that matches what's found in the array at items[i].text ==> which calls on the object list in the array we're referencing from that was already in localStorage, finds the item at i position and gives us its text value from the text key
      // setting data attribute of item. So dataset.anything gives it a dataset of anything.
      //a data-anything is a custom property. In this case, we're using it to avoid the fact that the system would otherwise read the text with an x at the end b/c of the button, so we don't want that to get in the way of everything else we're doing. This allows us to get the actual item w/o getting mucked up by the x button.
      // Question I want to ask at office hours on Monday (if no one answers it before then): If we were putting a dataset into our actual HTML (instead of putting one there via JS), what would that look like? I can't picture the actual syntax in the HTML.
      itemElem.dataset.item = items[i].text

      // this checks if the array on localStorage was left as marked done or not done last time the user was on the app
      if(items[i].isDone) {
        itemElem.className = 'todo green'
      } else {
        itemElem.className = 'todo'
      }

      // so it's pulling the item object from the array on localStorage and telling it what to put back on the page in the itemElem li that was just created
      itemElem.innerHTML =`
        ${items[i].text}
        <button class="delete">x</button
        `
      // take that itemElem li that we just created and actually adding it to the ul in the body. The append part means that it's added as the last thing between the ul tags.
      document.getElementById('items').append(itemElem)
    }
    // So at this point, the above loop has put us back to where the user last left things off from a previous visit

    // this is where a user begins if the items array was null, this is also where return users can begin to continue to modify their list
    // Advice from Q: typically best to put any event listeners below the other stuff you're coding for in your JS

    // get thing with id = 'addItem' (which is the button after our input), then listen for 'click'. So basically when you click the add item button. Do the following...
    document.getElementById('addItem').addEventListener('click', event => {

      // In any form, if you click a button, it has a number of default things it tries to do. We're disabling that b/c we don't want any of what it does. My impression from how Q talked about this was that he seemed to be saying that this is ALWAYS something you want to do (kinda like how we always want to have a reset file linked for our css).
      event.preventDefault()

      // WE STOPPED HERE when going through this in office hours after class Friday

      // every time someone clicks 'addItem', add itemObj
      let itemObj = {
        // the value of what was entered into the input with id="item" is stored under the text key
        text: document.getElementById('item').value,
        // this isDone key will let us mark each item as done or not. Use a bulleon value. Since the item is just now being added to itemObj, it is not yet done. Which is why we're setting it to false.
        isDone: false
      }
      
      // take the info we just generated for itemObj and (aka:push) it to array items
      items.push(itemObj)

      // then let's put that same items array (with its new object that we just pushed to it in the previous line of code) in localStorage and placing the array items into localStorage. localStorage only accepts strings and numbers. We use JSON.stringify(items) to make the items array into a string that still retains the structure of the array.
      //  JSON.stringify makes sure that the items array keeps its array style. Otherwise localStorage tries to turn it into a single non-array string.
      localStorage.setItem('items', JSON.stringify(items))

      // so sofar we have made the new object and stored it in localStorage. Now go to localStorage but nothing is added to the page yet.
      // so now, let's get the items from localStorage, and put them on the page.

      //create a new <li> we're gonna give it the variable itemElem
      let itemElem = document.createElement('li')
      
      // set dataset of itemElem to the value that was put in the input with id="item"
      itemElem.dataset.item = document.getElementById('item').value

      // give itemElem a class name "todo"
      itemElem.className = 'todo'
      
      // set html of the li itemElem: grab the text value from input w/ id="item" & follow it up with a button with class="delete" and button text x
      itemElem.innerHTML = `
        ${document.getElementById('item').value}<button class="delete">x</button>
        `
        
      // put new li 'itemElem' as the last thing in the element with id="items" (which is the ul we have up in the HTML). So we're adding the li we've just defined to the ul that we have in our html.
      document.getElementById('items').append(itemElem)
      
      // clear the input field of the input with id="item"
      document.getElementById('item').value = ''
    })

    // so at this point, we've told it that each new item put into the input gets set as a li then put into the ul. Each li has the following: dataset that matches the value of the input, has class name 'todo', and the html content within the li tag puts the value of the input as text and a button with class="delete" that shows an x on the button

    //everything that happens on the doc gets this event listener that we code right after this section of comments. We use this method of a global listener to handle dynamic elements that weren't in original HTML we have typed above. This allows us to direct it how to act when we click on things that were only added to the HTML via our JS.
    // this listens for ANY click ANYWHERE on the screen.
    document.addEventListener('click', event => {
      

      // event.target tells you the thing the event happened to. The event we're looking for is clicks. So event.target will tell us what thing was clicked
      // so this if statement is saying for ANY click, look at the event target, if the list of classes of the targeted/clicked element contains 'todo', then do ___ .
      // keep in mind, the elements that we have marked with the 'todo' class are the <li> elements. So basically this means we're saying "IF you click on a li, then do ____."
      if (event.target.classList.contains('todo')) {
        // in the console.log display the dataset we assigned the li when the item was created --- as far as I know, this was just left here as a check that when we set the dataset, it was set correctly. I'm 99% sure you can delete this and it won't break the code.
        console.log(event.target.dataset.item)
        

        // loop through the items array looking for the object whose text matches the dataset of the event.target (aka: the dataset of the item that was clicked on, which remember, above we told it to basically take what was typed into the input and set it as the dataset of the li. The dataset of something is just a property that you can call upon for things such as this.)
        for (let i = 0; i < items.length; i++) {
          // look for the object in the items array whose text matches the dataset of the target that was clicked on
          if (items[i].text === event.target.dataset.item) {
            // When you find that object, change the isDone status.
            // recall that when we added the input text to the items array, we set isDone to be a bulleon (true/false). We set it to initially start off as false since when you add something to a todo list, it won't be done. So the first time we click on a li, it'll change it from the false value we had it start with to true (aka: marking it as done).
            // it takes isDone = true and makes it isDone = !true. !true means not true, which would of course be false.
            items[i].isDone = !items[i].isDone
          }
        }

        // so at this point, we have any list item the user has typed in stored to the items list in the localStorage, displayed that item as a li on the screen. We've also made it so that if you click any li, it finds it where it's stored on the localStorage and changes the recorded value of of the isDone for that object.

        // I have no idea what this does. I know the JSON.stringify(items) has to do with making sure that when we set the item that's a part of the items array to localStorage that the items array maintains its array structure. But IDK why that's important to do here or what exactly that accomplishes in the big picture of what's going on at this point in the code.
        // Devin's comments indicate that all this does is updating the localStorage to reflect the change that we just made to the isDone status.
        localStorage.setItem('items', JSON.stringify(items))
        

        // So next in the list of things we want to happen when a li is clicked on, we want it to change color. If it was black text, change it to green. If it's green text, change it back to black. This is just a visual representation that we're adding to coordinate with the isDone status that's stored in localStorage.
        // NOTE: this color change action is NOT directly linked to the isDone status. We're simply setting it up so that the same action (click the li) that changes isDone also changes the color. The color is NOT changing as a result of a change in the isDone status. It's changing as a result of the click on the li and that same click also incidentally changes the isDone status of the item...but neither are directly related to the other.
        // So to accomplish this color change on click, we add or take away a class="green" to the li and then we can go up and define the class in the css style to set color: green. So we're checking if the li already has the class="green" if it does, we take it away. If it doesn't have the class="green", we add it.
        

        //check the list of classes associated with event.target to see IF event.target has class="green"
        if (event.target.classList.contains('green')) {
          // if it does have class="green" in its list of classes, remove that class
          event.target.classList.remove('green')
        } else {
          // if doesn't have class="green" in its list of classes, add it
          event.target.classList.add('green')
        }

        // so far with this recent section, we've been within the true part of the IF statement where we outline what to do if the detected click was on an element with the class="todo" (aka: what to do if we click an li). We've told the system to change the isDone status and change the text color when the detected click was on an element with class="todo". We are now at the end of that section. Now we move on to the else if that will outline what to do with clicks on other targets.

        // the else if states that if the click detected is on an element that contains class="delete", do the following. Remember, we marked those x buttons at the end of each li to have a class="delete". So in this section event.target is referencing that we've clicked on something with the "delete" class, which we know is those x buttons.
      } else if (event.target.classList.contains('delete')) {
      
        // parentNode has to do with how html tags are nested. The parentNode of an element would be the thing that is the next level of html that is nested around the element that we're talking about.
        // So in this case, our event.target is those x buttons. The HTML we have with the x buttons basically is `<li> ${item.value} <button class="delete">x</button> </li>`. So you can see how the <li> tags are the first thing that wraps around the <button> tags (not shown here of course is the other HTML that wraps around the <li> such as <ul> and <body>, etc). So since the <li> tags are the first thing that wraps around the <button> tags, that makes <li> the parentNode in this case.
        // So, the console.log here is saying to log the dataset of the element that is the parentNode of the event.target. So log the dataset that's assigned to the li. Which, if you recall, is just what was typed in the input field when we created that li.
        console.log(event.target.parentNode.dataset.item)

        // loop through the dataset and find that object which matches (is equal to) the dataset of the element that is the parentNode of the event.target. Since event.target is the x buttons, the parentNode of the event.target is the li. We're finding the object in the array that matches the dataset of the li that contains the x button the user clicked on.
        for(let i = 0; i < items.length; i++) {
          if(items[i].text === event.target.parentNode.dataset.item) {
            // Not sure here, but I'm guessing splice means to cut out (delete) that section from the array that's stored to localStorage??? But the exact syntax I don't understand.
            // OK, looking at Devin's comments: the loop combined with the if statement (the two lines of code immediately above this set of comments) finds the item in the array that is the parentNode of the event.target (aka: the li that contains the x button that was clicked), and based on it being at the i position w/in the array, cut out/delete everything in that i-th position of the items array.
            // Still not 100% sure what the 1 means in the syntax...maybe it's start at i position (aka: the position that matched our if criteria) of the array and only delete one piece of the array? as in, if it were a 2 instead, we'd start at i and delete i and i+1 (the item after i)??
            items.splice(i, 1)
          }
        }
        
        // yeah, IDK what this does.       
        // Devin's comments indicate that this basically updates/refreshes what's stored in the localStorage
        localStorage.setItem('items', JSON.stringify(items))
        
        // this removes the HTML code for the <li> parentNode so that it disappears from the page. Whereas the splice command up in the loop just above here removes it from the localStorage array.
        event.target.parentNode.remove()

        
      // end of the else if section that dictates what happens when we click the item with class="delete" (aka: when we click the x buttons)
      }
        
    // end of the instructions of what to do for ANY click on the site (that global listen for click)
    })

  </script>
</body>
</html>